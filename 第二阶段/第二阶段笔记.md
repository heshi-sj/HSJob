spring简介：
         spring是分层的full-stack轻量级开源框架，以IOC和AOP为核心，提供了展现层spring mvc 和业务事务管理，
   可以灵活的整合第三方的框架和类库，已经成为使用最多的Jave EE企业级应用框架


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
spring的优势
    1，方便解耦，简化开发
        通spring提供IOC容器，可以将对象间的依赖关系交由spring进行控制，避免硬编码造成的过度程序耦合，用户也
        不币再为单例模式类，属性文件解析等这些很底层的需求编写代码，可以更专注上层的应用；

2.AOP的支持：通过spring的aop功能，方便进行切面编程，许多不容易用传统的OOP实现的功能可以通过AOP轻松应对


3.声明事物的支持：通过声明的方式灵活的进行事务管理，提高开发效率和质量 ，，，，，@Transactional

4.方便程序的测试：可以用非容器的依赖的编程方式进行几乎所有的测试

5，方便集成各种优秀的框架：spring可以降低各种框架的使用难度，提供了对各种框架的支持


6.降低Java EE API的使用难度 ：jdbc ,javamail,远程调用等进行了薄薄的封装

     第四届￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥4





第二部分   核心思想
       注意： IOC和AOP不是spring提出的，在spring之前就有了，偏向理论化
  第一节：1.什么是AOP？
              IOC : Inversion of  Control(控制反转/反转控制)，它是一种思想不是一种技术的体现；
             描述的事情;java领域的对象的创建，管理问题
             传统的开发方式：如果A依赖于B往往会在A中new一个B；
               IOC的思想下开发我们不需要new对象，而是由IOC容器去帮助我们实例化对象并且管理它，我们需要使哪个对象直接去问ioc容器要就行了


控制：对象创建的权限，对象的实例化，管理
反转：控制权交给外部环境





@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2
第二节，ioc解决的问题
              1.对象之间的耦合问题；


￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥
IOC和DI关系：他们描述的是同一件事情————对象实例化及依赖关系维护这件事情
                     IOC站在对象的角度，对象的实例化及其管理的权限交给了反转容器
                     DI站在容器的角度，容器会把对象依赖的其他对象注入，比如A对象实例化过程中因为声明了一个B类型的属性，那么久需要容器把B对象注入给A；



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
AOP思想：1.什么是AOP  ：Aspect oriented   Programming    面向切面编程，是OOP的一个延续,OOP:封装，继承，多态。OOP;垂直的纵向的继承体系，可以解决大多数代码重复的问题，但是许多方法中
                                           相同位置出现了代码，OOP就解决不了

        在多个纵向流程中出现的相同的子流程代码，我们称为横切逻辑代码，应用场景：一般是事务控制，权限校验，日志;
             问题：代码重复问题
                      横切逻辑代码和业务逻辑代码混合，
                 2.AOP解决什么问题;
                             横向抽取逻辑，将横切逻辑的代码和业务逻辑代码分析；代码拆分容易，在不改变横切逻辑的情况下，增强横切逻辑代码，避免横切逻辑代码重复

   
                 3.什么是面向切面：
                             切：指的是横切逻辑，原有业务逻辑代码不能动，只能操作横切逻辑代码，所以面向横切逻辑；
                            面：横切逻辑代码往往会影响的是很多方法，每个方法都如同一个点，多个点构成面，有一个面的概念在里面，


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
问题一   实例化对：1，new   2反射    Class.forName("全限定类名");全限定类名配置在XML中
            使用工厂来通过反射技术来生产对象，工厂模式是解耦合非常好的一种方式；



             工厂类：读取解析xml,然后通过反射技术实例化对象给外部提供获取对象的接口方法



￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥










&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&7
数据库事务归根揭底是Connection事务。Connection.commit();
                                                               Connection.rollback();


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
动态代理  ：  代理：


jdk的动态代理，它会要求你原有的委托对象必须要实现接口  ;obj.getClass().getInterfaces(),
cglib动态代理不需要，委托对象，都可以



！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
Spring框架IOC的实现
         1，纯xml   （bean信息定义全部配置在xml中）
                1.1javese：ApplicationConxt    applicationConxt    =new  ClassPathApplicationConxt (''beans.xml)   
                                                                                                           FileSystemXmlApplicationConxt   (''c:/beans.xml) 



                 1.2javeweb:ContextListener(监听器去加载xml)
                     
   


          2.xml+ 注解：部分bean使用xml定义，部分bean使用注解定义     
                       
                              2.1javese：ApplicationConxt    applicationConxt    =new  ClassPathApplicationConxt (''beans.xml)   
                                                                                                           FileSystemXmlApplicationConxt   (''c:/beans.xml) 



                      
           
          3. 纯注解模式
                所有的bean都用注解来定义    ：启动：读取java类

                               3.1javese：ApplicationConxt    applicationConxt    =new  AnnotationConfigApplicationConxt (springconfig.class) ;  

                                                                                                          
                                  3.2javeweb:ContextListener(监听器去加载注解配置类)


！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！1
beanfactory和applicationContext

           BeanFactory是Spring框架中IoC容器的顶层接⼝,它只是⽤来定义⼀些基础功能,定义⼀些基础规范,⽽
ApplicationContext是它的⼀个⼦接⼝，所以ApplicationContext是具备BeanFactory提供的全部功能
的



 Spring 的优势
整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀
天，就能体会到它的⼀些优势。
⽅便解耦，简化开发
通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的
过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更
专注于上层的应⽤。
AOP编程的⽀持
通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过
AOP轻松应付。
声明式事务的⽀持
@Transactional
可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼
开发效率和质量。
⽅便程序的测试
可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的
事情。
⽅便集成各种优秀框架
Spring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、
Quartz等）的直接⽀持。
降低JavaEE API的使⽤难度
Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤
难度⼤为降低。
源码是经典的 Java 学习范例
Spring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对
Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。



IOC*******************************************************************************
IoC Inversion of Control (控制反转/反转控制)，注意它是⼀个技术思想，不是⼀个技术实现
描述的事情：Java开发领域对象的创建，管理的问题
传统开发⽅式：⽐如类A依赖于类B，往往会在类A中new⼀个B的对象
IoC思想下开发⽅式：我们不⽤⾃⼰去new对象了，⽽是由IoC容器（Spring框架）去帮助我们实例化对
象并且管理它，我们需要使⽤哪个对象，去问IoC容器要即可
我们丧失了⼀个权利（创建、管理对象的权利）,得到了⼀个福利（不⽤考虑对象的创建、管理等⼀系列
事情）
为什么叫做控制反转？
控制：指的是对象创建（实例化、管理）的权利
反转：控制权交给外部环境了（spring框架、IoC容器）


DI*********************************************************************

DI：Dependancy Injection（依赖注⼊）:容器的角度



￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥事务￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥4
事务指逻辑上的⼀组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。从⽽确保了数
据的准确与安全。


（（（（（（（（（（（（（（（（（（（（（（（（（（特性）））））））））））））））））））））））））））

     原⼦性（Atomicity） 原⼦性是指事务是⼀个不可分割的⼯作单位，事务中的操作要么都发⽣，要么都
不发⽣。
从操作的⻆度来描述，事务中的各个操作要么都成功要么都失败
⼀致性（Consistency） 事务必须使数据库从⼀个⼀致性状态变换到另外⼀个⼀致性状态。
例如转账前A有1000，B有1000。转账后A+B也得是2000。
⼀致性是从数据的⻆度来说的，（1000，1000） （900，1100），不应该出现（900，1000）
隔离性（Isolation） 事务的隔离性是多个⽤户并发访问数据库时，数据库为每⼀个⽤户开启的事务，
每个事务不能被其他事务的操作数据所⼲扰，多个并发事务之间要相互隔离。
⽐如：事务1给员⼯涨⼯资2000，但是事务1尚未被提交，员⼯发起事务2查询⼯资，发现⼯资涨了2000
块钱，读到了事务1尚未提交的数据（脏读）
持久性（Durability）
持久性是指⼀个事务⼀旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发⽣故障
也不应该对其有任何影响。
5.1.3 事务的隔离级别
不考虑隔离级别，会出现以下情况：（以下情况全是错误的），也即为隔离级别在解决事务并发问题
脏读：⼀个线程中的事务读到了另外⼀个线程中未提交的数据。
不可重复读：⼀个线程中的事务读到了另外⼀个线程中已经提交的update的数据（前后内容不⼀样）
                                                 

















                









